// Generated by CoffeeScript 1.9.1
"use strict";
var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

angular.module("perform").service("NineBox", [
  function() {
    this.cache = {};
    this.ratings = {
      0: {
        name: "Too New / NA",
        weight: {
          performance: 0,
          potential: 0
        }
      },
      1: {
        name: "Improvement Needed",
        weight: {
          performance: 1,
          potential: 1
        }
      },
      2: {
        name: "Inconsistant",
        weight: {
          performance: 3,
          potential: 2
        }
      },
      3: {
        name: "Developing",
        weight: {
          performance: 3,
          potential: 5
        }
      },
      4: {
        name: "Achieves",
        weight: {
          performance: 5,
          potential: 5
        }
      },
      5: {
        name: "Achieves+",
        weight: {
          performance: 5.5,
          potential: 6
        }
      },
      6: {
        name: "Exceeds",
        weight: {
          performance: 8,
          potential: 8
        }
      }
    };
    this.ratingFn = function(rating, token) {
      return this.ratings[rating].weight[token];
    };
    this._getBoxEdges = function(ratings, weights) {
      var allModelKeys, edgeX, edgeY, edges, name, rating, scoreX_max, scoreX_min, scoreX_normal, scoreY_max, scoreY_min, scoreY_normal, weightX, weightY, weightsX, weightsY;
      allModelKeys = weights.contents.modelkeys;
      weightsX = weights['weights-performance'].latest_review.review_body;
      weightsY = weights['weights-potential'].latest_review.review_body;
      scoreX_min = 0;
      scoreX_normal = 0;
      scoreX_max = 0;
      scoreY_min = 0;
      scoreY_normal = 0;
      scoreY_max = 0;
      for (name in ratings) {
        rating = ratings[name];
        if (indexOf.call(allModelKeys, name) < 0) {
          continue;
        }
        if (!name.match(/ratings/)) {
          continue;
        }
        weightX = weightsX != null ? weightsX[name] : void 0;
        if (!_.isNumber(weightX)) {
          weightX = 3;
        }
        weightY = weightsY != null ? weightsY[name] : void 0;
        if (!_.isNumber(weightY)) {
          weightY = 3;
        }
        scoreX_min += weightX * this.ratingFn(0, "performance");
        scoreX_normal += weightX * this.ratingFn(4, "performance");
        scoreX_max += weightX * this.ratingFn(6, "performance");
        scoreY_min += weightY * this.ratingFn(0, "potential");
        scoreY_normal += weightY * this.ratingFn(4, "potential");
        scoreY_max += weightY * this.ratingFn(6, "potential");
      }
      edgeX = (scoreX_max - scoreX_min) / 3;
      edgeY = (scoreY_max - scoreY_min) / 3;
      console.log(scoreX_min, scoreX_normal, scoreX_max, edgeX);
      console.log(scoreY_min, scoreY_normal, scoreY_max, edgeY);
      edges = {
        x: {
          min: scoreX_min,
          max: scoreX_max,
          normal: scoreX_normal,
          edge: edgeX
        },
        y: {
          min: scoreY_min,
          max: scoreY_max,
          normal: scoreY_normal,
          edge: edgeY
        }
      };
      console.log(edges);
      return edges;
    };
    this._getPercent = function(score, edge) {
      var currEdge, longEdge, percent;
      longEdge = edge.max - edge.min;
      currEdge = score - edge.min;
      if (currEdge === 0) {
        percent = 0;
      } else {
        percent = currEdge / longEdge;
      }
      return percent;
    };
    this._getPosition = function(edges, scoreX, scoreY) {
      var data, percentX, percentY, x, y;
      percentX = _.max([_.min([this._getPercent(scoreX, edges.x), 1]), 0]);
      percentY = _.max([_.min([this._getPercent(scoreY, edges.y), 1]), 0]);
      x = _.max([_.min([Math.floor(3 * percentX), 2]), 0]);
      y = _.max([_.min([Math.floor(3 * percentY), 2]), 0]);
      console.log("Position (internal): " + x + ", " + y);
      console.log("Position (display):  " + x + ", " + (2 - y));
      data = {
        pos: [x, 2 - y],
        percent: [percentX, percentY],
        percent_str: [Math.round(percentX * 100), Math.round(percentY * 100)]
      };
      return data;
    };
    this.calculateScore = function(review, weights) {
      var allModelKeys, name, rating, ratings, scoreX, scoreY, weight, weightsX, weightsY;
      ratings = review.review_body || {};
      allModelKeys = weights.contents.modelkeys;
      weightsX = weights['weights-performance'].latest_review.review_body;
      weightsY = weights['weights-potential'].latest_review.review_body;
      scoreX = 0;
      for (name in ratings) {
        rating = ratings[name];
        if (indexOf.call(allModelKeys, name) < 0) {
          continue;
        }
        if (_.isNumber(rating)) {
          weight = weightsX != null ? weightsX[name] : void 0;
          if (!_.isNumber(weight)) {
            weight = 3;
          }
          scoreX += this.ratingFn(rating, "performance") * weight;
        }
      }
      scoreY = 0;
      for (name in ratings) {
        rating = ratings[name];
        if (indexOf.call(allModelKeys, name) < 0) {
          continue;
        }
        if (_.isNumber(rating)) {
          weight = weightsY != null ? weightsY[name] : void 0;
          if (!_.isNumber(weight)) {
            weight = 3;
          }
          scoreY += this.ratingFn(rating, "potential") * weight;
        }
      }
      return [scoreX, scoreY];
    };
    this.calculate = function(review, weights) {
      var data, edges, pos, ratings, ref, scoreX, scoreY;
      ratings = review.review_body;
      ref = this.calculateScore(review, weights), scoreX = ref[0], scoreY = ref[1];
      console.log("[ninebox]: scores: " + review.uid + ": " + scoreX + ", " + scoreY);
      edges = this._getBoxEdges(ratings, weights);
      pos = this._getPosition(edges, scoreX, scoreY);
      console.log("[ninebox]: position: " + review.uid + ": " + pos);
      data = {
        pos: pos.pos,
        percent: pos.percent,
        percent_str: pos.percent_str,
        score: [scoreX, scoreY]
      };
      return data;
    };
  }
]);
