// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  angular.module("perform").service("Cache", [
    "WS", "$q", "$timeout", "Portal", "Auth", "$state", "$sanitize", function(WS, $q, $timeout, Portal, Auth, $state, $sanitize) {
      var anonUser;
      this.userCache = {};
      this.reviewsCache = {
        'review': {},
        'self-review': {},
        'weights-performance': {},
        'weights-potential': {}
      };
      this.templateCache = {};
      this.feedbackCache = {};
      this.allReviewsMetaData = {};
      anonUser = {
        uid: 'anonymous',
        cn: 'Guest User'
      };
      this.appMetaData = {};
      this.reset = function() {
        this.userCache = {};
        this.reviewsCache = {
          'review': {},
          'self-review': {},
          'weights-performance': {},
          'weights-potential': {}
        };
        this.templateCache = {};
        this.feedbackCache = {};
        this.allReviewsMetaData = {};
        return this.appMetaData = {};
      };
      this.getAppMetadata = function() {
        'Get metadata of the app itself.';
        var metadata;
        if (!this.appMetaData.metadata) {
          return WS.getAppMetadata().then((function(_this) {
            return function(response) {
              _this.appMetaData.metadata = response;
              return response;
            };
          })(this));
        } else {
          metadata = this.appMetaData.metadata;
          return $q.when(metadata);
        }
      };
      this.userCache[anonUser.uid] = anonUser;
      this.populateReviewsCache = function(response, reviewType) {
        var cached, reviewkey, rname, uid, year;
        uid = response.latest_review.uid;
        year = response.latest_review.year;
        rname = response.latest_review.rname;
        reviewkey = this.reviewkey(uid, year, rname);
        cached = this.reviewsCache[reviewType][reviewkey];
        if (cached) {
          return _.assign(this.reviewsCache[reviewType][reviewkey], response);
        } else {
          return this.reviewsCache[reviewType][reviewkey] = response;
        }
      };
      this.getUser = function(uid) {
        'uid:user information pair is retrieved';
        var defer, user;
        if (!this.userCache[uid]) {
          console.log("Getting " + $sanitize(uid));
          return Portal.getUserInfo(uid).then((function(_this) {
            return function(response) {
              _this.userCache[response != null ? response.uid : void 0] = response;
              return response;
            };
          })(this));
        } else {
          defer = $q.defer();
          user = this.userCache[uid];
          defer.resolve(user);
          return defer.promise;
        }
      };
      this.getAllReviewsForUser = function(uid) {
        var defer;
        if (!this.allReviewsMetaData[uid]) {
          this.allReviewsMetaData[uid] = [];
          return WS.getUser(uid).then((function(_this) {
            return function(response) {
              var name, ref, review, reviews, year;
              ref = response.reviews.data;
              for (year in ref) {
                reviews = ref[year];
                for (name in reviews) {
                  review = reviews[name];
                  _this.allReviewsMetaData[uid].push({
                    'year': year,
                    'name': review.rname
                  });
                }
              }
              return _this.allReviewsMetaData[uid];
            };
          })(this));
        } else {
          defer = $q.defer();
          defer.resolve(this.allReviewsMetaData[uid]);
          return defer.promise;
        }
      };
      this.reviewkey = function(uid, year, rname) {
        return uid + "-" + year + "-" + rname;
      };
      this.massageReview = function(review) {
        var defer1, defer2, defer3;
        defer1 = $q.all(review.permitted_users.map((function(_this) {
          return function(uid) {
            return _this.getUser(uid);
          };
        })(this))).then((function(_this) {
          return function(users) {
            review.permitted_users = _.filter(users);
            return review;
          };
        })(this));
        defer2 = $q.all(review.contributors.map((function(_this) {
          return function(uid) {
            return _this.getUser(uid);
          };
        })(this))).then((function(_this) {
          return function(users) {
            review.contributors = _.filter(users);
            return review;
          };
        })(this));
        defer3 = $q.all(_.map(review.feedbacks, (function(_this) {
          return function(x) {
            return _this.getUser(x.reviewer);
          };
        })(this))).then((function(_this) {
          return function(users) {
            _.map(_.zip(review.feedbacks, users), function(x) {
              return x[0].reviewer_user = x[1];
            });
            return review.feedbacks_grouped = _.groupBy(review.feedbacks, function(x) {
              return x.reviewer;
            });
          };
        })(this));
        return $q.all([defer1, defer2, defer3]).then((function(_this) {
          return function(response) {
            return review;
          };
        })(this));
      };
      this.getReviewByUser = function(uid, year, rname, reviewType, forceUpdate) {
        var defer, response;
        if (forceUpdate == null) {
          forceUpdate = false;
        }
        'get notes from the cache if it exists, if not fetch\nfrom backend (using WS) and return it';
        if (forceUpdate || (!this.reviewsCache[reviewType][this.reviewkey(uid, year, rname)])) {
          return WS.getReviewByUser(uid, year, rname, reviewType).then((function(_this) {
            return function(response) {
              return _this.massageReview(response).then(function(ret) {
                _this.populateReviewsCache(response, reviewType);
                return response;
              });
            };
          })(this), function(response) {
            return $state.transitionTo('auth_error', {}, {
              location: 'replace',
              inherit: true,
              relative: $state.$current,
              notify: true
            });
          });
        } else {
          defer = $q.defer();
          response = this.reviewsCache[reviewType][this.reviewkey(uid, year, rname)];
          defer.resolve(response);
          return defer.promise;
        }
      };
      this.getReviewByUserMulti = function(requests, forceUpdate) {
        var cached, defer, defers, i, j, len, request, reviewType, rname, toResolve, uid, year;
        if (forceUpdate == null) {
          forceUpdate = false;
        }
        defers = [];
        toResolve = [];
        for (i = j = 0, len = requests.length; j < len; i = ++j) {
          request = requests[i];
          uid = request.uid;
          year = request.year;
          rname = request.rname;
          reviewType = request.review_type;
          if (forceUpdate || (!this.reviewsCache[reviewType][this.reviewkey(uid, year, rname)])) {
            toResolve.push(request);
          } else {
            defer = $q.defer();
            cached = this.reviewsCache[reviewType][this.reviewkey(uid, year, rname)];
            defers.push(defer.promise);
            defer.resolve([cached]);
          }
        }
        if (toResolve.length) {
          defer = WS.getReviewByUserMulti(toResolve).then((function(_this) {
            return function(response) {
              var k, len1, review;
              for (k = 0, len1 = response.length; k < len1; k++) {
                review = response[k];
                _this.massageReview(review).then(function(ret) {
                  return _this.populateReviewsCache(ret, ret.latest_review.review_type);
                });
              }
              return response;
            };
          })(this));
          defers.push(defer);
        }
        return $q.all(defers).then((function(_this) {
          return function(responses) {
            var index, item, k, len1, orderedResponse, req, requestOrder, responseOrder, x;
            responses = _.flatten(responses);
            orderedResponse = [];
            requestOrder = (function() {
              var k, len1, results1;
              results1 = [];
              for (k = 0, len1 = requests.length; k < len1; k++) {
                x = requests[k];
                results1.push(x.uid);
              }
              return results1;
            })();
            responseOrder = (function() {
              var k, len1, results1;
              results1 = [];
              for (k = 0, len1 = responses.length; k < len1; k++) {
                x = responses[k];
                results1.push(x.latest_review.uid);
              }
              return results1;
            })();
            for (k = 0, len1 = requestOrder.length; k < len1; k++) {
              req = requestOrder[k];
              index = responseOrder.indexOf(req);
              item = responses[index];
              orderedResponse.push(item);
            }
            return orderedResponse;
          };
        })(this));
      };
      this.getTemplate = (function(_this) {
        return function(templateID) {
          'Get template from the cache if it exists, if not fetch\nfrom Template and return it';
          var defer, template;
          if (!_this.templateCache[templateID]) {
            return WS.getTemplate(templateID).then(function(response) {
              _this.templateCache[templateID] = response;
              return response;
            });
          } else {
            defer = $q.defer();
            template = _this.templateCache[templateID];
            defer.resolve(template);
            return defer.promise;
          }
        };
      })(this);
      this.getAdminData = function() {
        return WS.getAdminData(Auth.getUser().uid);
      };
      this.getAllReviewsByYear = function(year, rname) {
        'Get all users\' reviews of a particular year';
        return WS.getAllReviewsByYear(Auth.getUser().uid, year, rname);
      };
      this.getAuthUserInfo = (function(_this) {
        return function() {
          'Get Authenticated userinfo';
          return WS.getUser(Auth.getUser().uid).then(function(response) {
            var _, defers, ref, reviews, uids;
            uids = [];
            defers = [];
            ref = response.editable;
            for (_ in ref) {
              reviews = ref[_];
              defers = defers.concat(reviews['review'].map(function(review) {
                return _this.getUser(review.uid).then(function(response) {
                  return review.user = response;
                });
              }));
              defers = defers.concat(reviews['self-review'].map(function(review) {
                return _this.getUser(review.uid).then(function(response) {
                  return review.user = response;
                });
              }));
            }
            return $q.all(defers).then(function(retVal) {
              return response;
            });
          });
        };
      })(this);
      this.getFeedback = function(uid) {
        'Get feedback of a specified user';
        return WS.getFeedback(uid);
      };
      this.addFeedback = function(feedback, change_type) {
        'Commit feedback';
        return WS.addFeedback(feedback.uid, feedback.feedback_body, change_type);
      };
      this.portal = {};
      this.getAllAdmins = function() {
        return WS.getAllAdmins();
      };
      this.addAdmin = function(user) {
        return WS.addAdmin(user);
      };
      this.removeAdmin = function(user) {
        return WS.removeAdmin(user);
      };
      this.getAllUsers = function() {
        var allusers;
        if (!this.portal.allusers) {
          console.time('Portal.getUsers()');
          return Portal.getAllUsers().then((function(_this) {
            return function(response) {
              var i, j, len, results;
              console.timeEnd('Portal.getUsers()');
              response = response.hits.hits;
              results = [];
              for (j = 0, len = response.length; j < len; j++) {
                i = response[j];
                results.push(i._source);
              }
              return _this.portal.allusers = results;
            };
          })(this));
        } else {
          allusers = this.portal.allusers;
          return $q.when(allusers);
        }
      };
      $timeout((function(_this) {
        return function() {
          return _this.getAllUsers();
        };
      })(this), 1);
    }
  ]);

}).call(this);
