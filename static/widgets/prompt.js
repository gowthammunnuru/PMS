// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  angular.module("perform").directive("prompt", [
    "Colors", "Reviews", "Auth", function(Colors, Reviews, Auth) {
      return {
        restrict: "E",
        transclude: true,
        scope: true,
        templateUrl: function(element, attrs) {
          if (attrs.mode) {
            return "static/widgets/prompt." + attrs.mode + ".html";
          } else {
            return "static/widgets/prompt.html";
          }
        },
        compile: function(element, attrs) {
          return {
            pre: function(scope, element, attrs, controller, transclude) {
              return transclude(scope, function(items) {
                var x;
                return attrs.criteria = (function() {
                  var j, len, results;
                  results = [];
                  for (j = 0, len = items.length; j < len; j++) {
                    x = items[j];
                    if (x.innerHTML) {
                      results.push({
                        name: x.innerHTML,
                        desc: x.getAttribute('desc')
                      });
                    }
                  }
                  return results;
                })();
              });
            },
            post: function(scope, element, attrs) {
              var criterion, ref, ref1, uid;
              scope.headings = [
                {
                  name: 'Too new / NA',
                  pts: 0,
                  name_alt: "NA",
                  desc: "Unable to evaluate at this time; new to the position."
                }, {
                  name: 'Improvement needed',
                  pts: 1,
                  name_alt: "Not important at all",
                  desc: "A problem area that needs to be addressed."
                }, {
                  name: 'Partially Meets',
                  pts: 2,
                  name_alt: "Not particularly important",
                  desc: "Meets some of the expectations established but not all."
                }, 
                // {
                //   name: 'Developing',
                //   pts: 3,
                //   name_alt: "Somewhat important",
                //   desc: "Consistently meets expectations. However skill not fully developed; showing a steady progression in skill set; learning a new skill or department."
                // }, 
                {
                  name: 'Achieves',
                  pts: 3,
                  name_alt: "Important",
                  desc: "Performs at a level consistent with requirements of the job."
                }, {
                  name: 'Achieves+',
                  pts: 4,
                  name_alt: "Very important",
                  desc: "Sometimes goes above expectations."
                }, {
                  name: 'Exceeds',
                  pts: 5,
                  name_alt: "Must have",
                  desc: "Consistently goes above expectations; sets the standard."
                }
              ];
              scope.headings_weights = [
                {
                  name: 'NA',
                  pts: 0
                }, {
                  name: "Not particularly important",
                  pts: 1
                }, {
                  name: 'Somewhat important',
                  pts: 2
                }, {
                  name: 'Important',
                  pts: 3
                }, {
                  name: 'Very important',
                  pts: 4
                }, {
                  name: 'Must have',
                  pts: 5
                }
              ];
              scope.getHeading = function(pts) {
                var x;
                return ((function() {
                  var j, len, ref, results;
                  ref = scope.headings;
                  results = [];
                  for (j = 0, len = ref.length; j < len; j++) {
                    x = ref[j];
                    if (x.pts === pts) {
                      results.push(x);
                    }
                  }
                  return results;
                })())[0];
              };
              scope.blocktitle = attrs.blocktitle;
              scope.collapse = {
                icons: ['glyphicon-plus', ''],
                state: true
              };
              scope.bg = function(color) {
                if (color == null) {
                  color = Colors.colorScheme.invisilbe;
                }
                return {
                  'background-color': color[0],
                  'border-color': color[0]
                };
              };
              scope.overlayColor = function(color) {
                if (color == null) {
                  color = Colors.colorScheme.invisilbe;
                }
                return {
                  'background-color': "" + color[0]
                };
              };
              scope.palette = {
                colors: [scope.bg(Colors.colorScheme.gray), scope.bg(Colors.colorScheme.amber), scope.bg(Colors.colorScheme.lime), scope.bg(Colors.colorScheme.lightgreen), scope.bg(Colors.colorScheme.green), scope.bg(Colors.colorScheme.darkgreen), scope.bg(Colors.colorScheme.bluegrey)],
                selfReviewColors: [scope.overlayColor(Colors.colorScheme.gray), scope.overlayColor(Colors.colorScheme.amber), scope.overlayColor(Colors.colorScheme.lime), scope.overlayColor(Colors.colorScheme.lightgreen), scope.overlayColor(Colors.colorScheme.green), scope.overlayColor(Colors.colorScheme.darkgreen), scope.overlayColor(Colors.colorScheme.bluegrey)]
              };
              if (attrs.mode === 'multi' && !scope.user) {
                scope.mode = 'headings_only';
              } else {
                scope.mode = "prompt";
              }
              scope.sanitize = function(string) {
                return string.replace(/\W+/g, '-').toLowerCase();
              };
              scope.modelkey = function(string, namespace) {
                if (namespace == null) {
                  namespace = "";
                }
                return (scope.sanitize(namespace)) + "::" + (scope.sanitize(string));
              };
              scope.resetRating = function() {
                var j, len, ref, results, x;
                ref = scope.headings;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                  x = ref[j];
                  results.push(scope.bg());
                }
                return results;
              };
              if (scope.mode === "headings_only") {
                scope.review = {};
              } else {
                if ((ref = scope.review_type) === "weights-performance" || ref === "weights-potential") {
                  uid = scope.template_id;
                } else {
                  uid = scope.user.uid;
                }
                scope.latest_review = Reviews.getReviewPacketByUserAndYear(uid, scope.review_year, scope.review_name, scope.review_type);
                scope.review = (ref1 = scope.latest_review) != null ? ref1.review_body : void 0;
                if (scope.latest_review.uid !== Auth.getUser().uid && scope.review_type === 'self-review') {
                  scope.notEditable = true;
                }
              }
              scope.criteria = (function() {
                var j, len, ref2, results;
                ref2 = attrs.criteria;
                results = [];
                for (j = 0, len = ref2.length; j < len; j++) {
                  criterion = ref2[j];
                  results.push({
                    name: criterion.name,
                    desc: criterion.desc,
                    colors: scope.resetRating(),
                    selfReviewColors: scope.resetRating(),
                    value: scope.review[scope.modelkey(criterion.name, "ratings::" + scope.blocktitle)],
                    modelkey: scope.modelkey(criterion.name, "ratings::" + scope.blocktitle)
                  });
                }
                return results;
              })();
              if (scope.mode === "headings_only") {
                return;
              }
              scope.setColorRating = function(criterion, index, barType) {
                var i, j, ref2, results;
                if (barType == null) {
                  barType = 'colors';
                }
                'barType is either \'colors\'  or \'selfReviewColors\'\n  colors        : proper review\n  selfReviewColors : self-review';
                if (barType === 'colors') {
                  criterion.colorIndex = index;
                } else if (barType === 'selfReviewColors') {
                  criterion.selfReviewIndex = index;
                }
                results = [];
                for (i = j = 0, ref2 = scope.headings.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
                  if (i <= index) {
                    results.push(criterion[barType][i] = scope.palette[barType][index]);
                  } else {
                    results.push(criterion[barType][i] = barType === 'color' ? scope.bg() : scope.overlayColor());
                  }
                }
                return results;
              };
              scope.update = function(review, barType) {
                var j, len, ref2, ref3;
                if (!review) {
                  return;
                }
                ref2 = scope.criteria;
                for (j = 0, len = ref2.length; j < len; j++) {
                  criterion = ref2[j];
                  scope.setColorRating(criterion, parseInt(review[scope.modelkey(criterion.name, "ratings::" + scope.blocktitle)]), barType);
                }
                if ((ref3 = scope.review_type) === "weights-performance" || ref3 === "weights-potential") {
                  uid = scope.template_id;
                } else {
                  uid = scope.user.uid;
                }
                return scope.latest_review = Reviews.getReviewPacketByUserAndYear(uid, scope.review_year, scope.review_name, scope.review_type);
              };
              scope.$watch('review', function(newValue, oldValue) {
                return scope.update(scope.review, 'colors');
              }, true);
              scope.$watch('selfReview', function(newValue, oldValue) {
                if (scope.selfReview) {
                  return scope.update(scope.selfReview.review_body, 'selfReviewColors');
                }
              }, true);
              scope.$watch('latest_review', function(newValue, oldValue) {
                return scope.review_locked = scope.latest_review.locked || scope.latest_review.committed;
              }, true);
              scope.mouseover = function($event, index, criterion, item) {
                return scope.setColorRating(criterion, index);
              };
              scope.mouseout = function($event, index, criterion, item) {
                return scope.setColorRating(criterion, parseInt(scope.review[scope.modelkey(criterion.name, "ratings::" + scope.blocktitle)]));
              };
              scope.setRating = function(criterion, index, heading) {
                scope.review[scope.modelkey(criterion.name, "ratings::" + scope.blocktitle)] = heading.pts;
                scope.setColorRating(criterion, index);
              };
              scope.shouldHighlight = function(modelkey) {
                return indexOf.call(scope.missingModelKeys, modelkey) >= 0;
              };
            }
          };
        }
      };
    }
  ]);

}).call(this);
